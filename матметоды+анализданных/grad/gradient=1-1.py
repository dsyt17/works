# функция 2 переменных, постоянный шаг h
def f(x): # функция
    return 2*x[0]**2+x[0]*x[1]+x[1]**2

def f_grad(x): # градиент функции
    return [4*x[0]+x[1],x[0]+2*x[1]]

def f_grad_abs(x): # длина градиента
    return (x[0]**2+x[1]**2)**0.5

h = 0.5  #
x_k = [0.5,1]     # начальное значение
x_k1 = [0,0]
eps = 0.001 # точность для производной
k = 0

print('       №    x_k[0]   x_k[1]   f(x_k)')

while k<=30: # цикл по максимальному числу итераций
    if x_k[0]>0:
        print(f"{k:8}", "",'%.6f' % x_k[0], '%.6f' % x_k[1], '%.6f' % f(x_k))
    else:
        print(f"{k:8}", '%.6f' % x_k[0], '%.6f' % x_k[1], '%.6f' % f(x_k))
    
    
    if f_grad_abs(x_k) < eps:
        print('ups')
        break # завершение цикла, если модуль производной меньше заданной точности   
    l = f_grad(x_k)
    for i in range(2):
        x_k1[i] = x_k[i] - h*l[i]
    
    if f(x_k1) > f(x_k): # проверка - не перескочили ли минимум
        h = h/2
        print('aaaaaaaaaa')
        continue
    
    x_k = x_k1
    k += 1
   
